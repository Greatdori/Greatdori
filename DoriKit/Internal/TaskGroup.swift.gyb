//===---*- Greatdori! -*---------------------------------------------------===//
//
// TaskGroup.swift.gyb
//
// This source file is part of the Greatdori! open source project
//
// Copyright (c) 2025 the Greatdori! project authors
// Licensed under Apache License v2.0
//
// See https://greatdori.memz.top/LICENSE.txt for license information
// See https://greatdori.memz.top/CONTRIBUTORS.txt for the list of Greatdori! project authors
//
//===----------------------------------------------------------------------===//

import Foundation

%{
    from itertools import repeat
    
    typeNames = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
}%

% for i in range(len(typeNames)):
%     typeAnnotation = ", ".join(typeNames[0:(i + 1)])
%     parameters = ", ".join(map((lambda n: f"_ task{n}: @Sendable @escaping () async -> {n}"), typeNames[0:(i + 1)]))
internal func withTasksResult<${": Sendable, ".join(typeNames[0:(i + 1)])}: Sendable>(${parameters}) async -> (${typeAnnotation}) {
    await withTaskGroup { (group: inout TaskGroup<(String, any Sendable)>) in
        % for t in typeNames[0:(i + 1)]:
        group.addTask {
            ("${t}", await task${t}())
        }
        % end
        var result: (${", ".join(map((lambda n: f"{n}?"), typeNames[0:(i + 1)]))}) = (${", ".join(repeat("nil", i + 1))})
        for await unsafe (id, r) in group {
            % for t in typeNames[0:(i + 1)]:
            if id == "${t}" {
                % if i != 0:
                result.${typeNames.index(t)} = (r as! (${t}))
                % else:
                result = (r as! (${t}))
                % end
                continue
            }
            % end
        }
        % if i != 0:
        return (${", ".join(map((lambda n: f"result.{n}!"), range(i + 1)))})
        % else:
        return result!
        % end
    }
}
% end
