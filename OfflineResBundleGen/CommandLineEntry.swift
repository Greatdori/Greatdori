//===---*- Greatdori! -*---------------------------------------------------===//
//
// CommandLineEntry.swift
//
// This source file is part of the Greatdori! open source project
//
// Copyright (c) 2025 the Greatdori! project authors
// Licensed under Apache License v2.0
//
// See https://greatdori.memz.top/LICENSE.txt for license information
// See https://greatdori.memz.top/CONTRIBUTORS.txt for the list of Greatdori! project authors
//
//===----------------------------------------------------------------------===//

import DoriKit
import Foundation
import ArgumentParser

@main
struct CommandLineEntry: AsyncParsableCommand {
    @Flag
    var locale: LocaleFlag = .all
    @Option(name: .shortAndLong, help: "Output path, should be a directory.", transform: URL.init(fileURLWithPath:))
    var output: URL
    @Option
    var maxConnectionCount: Int = 100
    @Option(name: .shortAndLong, help: "The Github token used to upload data.")
    var token: String? = nil
    @Option(name: .shortAndLong, help: "The LastID used to fetch updates. Temporary use only.")
    var lastID: Int? = nil
    mutating func run() async throws {
        var isDirectory: ObjCBool = false
        if !FileManager.default.fileExists(atPath: output.path(percentEncoded: false), isDirectory: &isDirectory) {
            try FileManager.default.createDirectory(at: output, withIntermediateDirectories: true)
        } else if !isDirectory.boolValue {
            print("error: output path is not a directory", to: &stderr)
            Foundation.exit(EXIT_FAILURE)
        }
        
        LimitedTaskQueue.shared = .init(limit: maxConnectionCount)
        
        if locale == .all {
            await generateAPI(to: output)
            try await generate(to: output)
            // Dori resource should be generated by a separated run,
            // that is it's not covered by `.all`.
        } else if locale == .api {
            await generateAPI(to: output)
        } else if locale == .doriResource {
            try await generateDoriResource(to: output)
        } else if locale == .strandMain {
            await updateAssets(in: output, withToken: token, lastID: lastID)
        } else if locale == .debug {
            print("[$][DEBUG] Start Debug Process")
            await debugProcess(output: output, token: token, lastID: lastID)
        } else {
            print("Generating for \(locale.rawValue.uppercased())...\n")
            let localizedOutput = output.appending(path: locale.rawValue)
            if !FileManager.default.fileExists(atPath: localizedOutput.path(percentEncoded: false)) {
                try FileManager.default.createDirectory(at: localizedOutput, withIntermediateDirectories: true)
            }
            try await generateLocale(locale.apiLocale, to: localizedOutput)
        }
    }
    
    enum LocaleFlag: String, EnumerableFlag {
        case api
        case all
        case jp
        case en
        case tw
        case cn
        case kr
        case doriResource
        case debug
        case strandMain
        
        var apiLocale: DoriAPI.Locale {
            switch self {
            case .en: .en
            case .tw: .tw
            case .cn: .cn
            case .kr: .kr
            default: .jp
            }
        }
    }
}

func debugProcess(output: URL, token: String?, lastID: Int?) async {
//    print(await readLastID())
//    await updateLastID()
//    print(await readLastID())
//    await prepareUpdateFolder(forLocale: .jp, from: "/Users/himmel/gd-offline-res", to: output.absoluteString)
    print(output.absoluteString.dropURLPrefix())
    
    do  {
        try await updateAssets(in: output, withToken: token, lastID: lastID)
    } catch {
        print("updateAssets failure: \(error)")
    }
        
        
    do {
        // 0. Initialization
        print("[$][Debug][jp/basic] Started with unknown number of items.")
        let startTime = CFAbsoluteTimeGetCurrent()
        var updatedItemsCount = 0
        fflush(stdout)
        
        // 1. Pull
        let script = #"""
echo "Debug Git Pull 111"
git config --global --add safe.directory "\#(output.absoluteString.dropURLPrefix())"
cd "\#(output.absoluteString.dropURLPrefix())"

echo "Debug Git Pull 222"

git checkout "jp/basic"

echo "Debug Git Pull 333"

# Retry git pull --rebase up to 10 times
for i in {1..10}; do
  if git pull --rebase; then
    break
  fi
done

echo "Debug Git Pull 444"
"""#
        let (status, output) = try await runBashScript(script, commandName: "Git Pull", reportBashContent: false,  expectedStatus: nil, useEnhancedErrorCatching: false, viewFailureAsFatalError: false)
        print("[✓][Update][jp/basic] Git pulled. Status \(status).")
        fflush(stdout)
    } catch {
        print("[×][Update][jp/basic] Git pull failed. Error: \(error).")
    }
}
